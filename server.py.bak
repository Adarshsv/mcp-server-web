import os
import re
import asyncio
from typing import Optional, List, Dict, Any

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from openai import OpenAI
from duckduckgo_search import DDGS

# -------------------- APP SETUP --------------------

app = FastAPI(title="CAST Ticket Analyzer")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# -------------------- MODELS --------------------

class AnalyzeRequest(BaseModel):
    ticket_id: Optional[int] = None
    query: Optional[str] = None


# -------------------- UTILITIES --------------------

GENERIC_DOCS = [
    {"title": "CAST AIP Documentation Home", "url": "https://doc.castsoftware.com/"},
    {"title": "CAST AIP Knowledge Base", "url": "https://doc.castsoftware.com/kb/"},
    {"title": "CAST AIP Troubleshooting Guide", "url": "https://doc.castsoftware.com/troubleshoot/"},
]


def is_ticket_id(text: str) -> bool:
    return bool(re.fullmatch(r"\d{4,7}", text.strip()))


# -------------------- DOCUMENT SEARCH (FIRST) --------------------

async def search_docs(keyword: str) -> List[Dict[str, str]]:
    results = []

    with DDGS() as ddgs:
        for r in ddgs.text(
            f"{keyword} site:doc.castsoftware.com",
            max_results=5
        ):
            results.append({
                "title": r.get("title"),
                "url": r.get("href"),
                "comment": f"Mentions '{keyword}'"
            })

    return results


# -------------------- TICKET SEARCH (SECOND) --------------------

async def search_solved_tickets(keyword: str) -> List[Dict[str, Any]]:
    """
    Placeholder for Zendesk solved-ticket search.
    Replace with real Zendesk API search.
    """
    return []


# -------------------- AI SUMMARY --------------------

async def ai_summary(text: str) -> Dict[str, Any]:
    resp = openai_client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a CAST AIP support expert."},
            {"role": "user", "content": text}
        ]
    )

    return {
        "summary": resp.choices[0].message.content.strip(),
        "confidence": 0.85
    }


# -------------------- CORE ANALYZER --------------------

async def analyze_text(query: str) -> Dict[str, Any]:
    response = {
        "query": query,
        "summary": "",
        "recommended_solution": "",
        "confidence": None,
        "related_tickets": [],
        "related_docs": []
    }

    # 1️⃣ DOC SEARCH FIRST
    docs = await search_docs(query)
    if docs:
        response["related_docs"] = docs
    else:
        response["related_docs"] = GENERIC_DOCS

    # 2️⃣ TICKET SEARCH
    response["related_tickets"] = await search_solved_tickets(query)

    # 3️⃣ AI SUMMARY (NON-BLOCKING FEEL)
    ai = await ai_summary(query)
    response.update(ai)

    return response


# -------------------- ROUTES --------------------

@app.post("/ticket/analyze")
async def analyze(req: AnalyzeRequest):
    if req.ticket_id:
        return await analyze_text(str(req.ticket_id))

    if req.query:
        if is_ticket_id(req.query):
            return await analyze_text(req.query)
        return await analyze_text(req.query)

    raise HTTPException(status_code=400, detail="ticket_id or query required")


# -------------------- BACKWARD COMPAT --------------------

@app.post("/ticket/details")
async def ticket_details(req: AnalyzeRequest):
    return await analyze(req)


@app.post("/ticket/search")
async def ticket_search(req: AnalyzeRequest):
    return await analyze(req)
